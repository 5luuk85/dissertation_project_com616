// #################################### MODIFIED SCRIPT USED FOR DISSERTATION PROJECT COM616 ####################################
//
/* Copyright (c) 2019 University of Washington//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation;
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// Author: SÃ©bastien Deronne <sebastien.deronne@gmail.com>
//
 
//
//  This example program can be used to experiment with spatial
//  reuse mechanisms of 802.11ax.
//
//  The geometry is as follows:
//
//                STA1          STA2
//                 |              |
//         x1 & y1 |              | x2 & y2
//                 |       d1     |
//                AP1 -----------AP2
//                 :
//              d2 :
//                 :
//                AP3
//                 |
//         x3 & y3 |
//                 |
//                STA3
//
//  STA1 and AP1 are in one BSS (with color set to 1), while STA2 and AP2 are in
//  another BSS (with color set to 2). The distances are configurable (d1 through d3).
//
//  STA1 is continuously transmitting data to AP1, while STA2 is continuously sending data to AP2.
//  Each STA has configurable traffic loads (inter packet interval and packet size).
//  It is also possible to configure TX power per node as well as their CCA-ED tresholds.
//  OBSS_PD spatial reuse feature can be enabled (default) or disabled, and the OBSS_PD
//  threshold can be set as well (default: -72 dBm).
//  A simple Friis path loss model is used and a constant PHY rate is considered.
//
//  In general, the program can be configured at run-time by passing command-line arguments.
//  The following command will display all of the available run-time help options:
//    ./ns3 run "wifi-spatial-reuse --help"
//
//  According to the Wi-Fi models of ns-3.36 release, throughput with
//  OBSS PD enabled (--enableObssPd=True) was roughly 6.5 Mbps, and with
//  it disabled (--enableObssPd=False) was roughly 3.5 Mbps.
//
//  This difference between those results is because OBSS_PD spatial
//  reuse enables to ignore transmissions from another BSS when the
//  received power is below the configured threshold, and therefore
//  either defer during ongoing transmission or transmit at the same
//  time.
//
//  Note that, by default, this script configures a network using a
//  channel bandwidth of 20 MHz. Changing this value alone (through
//  the --channelWidth argument) without properly adjusting other
//  parameters will void the effect of spatial reuse: since energy is
//  measured over the 20 MHz primary channel regardless of the channel
//  width, doubling the transmission bandwidth creates a 3 dB drop in
//  the measured energy level (i.e., a halving of the measured
//  energy). Because of this, when using the channelWidth argument
//  users should also adjust the CCA-ED Thresholds (via --ccaEdTrSta1,
//  --ccaEdTrSta2, --ccaEdTrAp1, and --ccaEdTrAp2), the Minimum RSSI
//  for preamble detection (via --minimumRssi), and the OBSS PD
//  Threshold (via --obssPdThreshold) appropriately. For instance,
//  this can be accomplished for a channel width of 40 MHz by lowering
//  all these values by 3 dB compared to their defaults.
//
//  In addition, consider that adapting the adjustments shown above
//  for an 80 MHz bandwidth (using a 6 dB threshold adjustment instead
//  of 3 dB) will not produce any changes when enableObssPd is enabled
//  or disabled. The cause for this is the insufficient amount of
//  traffic that is generated by default in the example: increasing
//  the bandwidth shortens the frame durations, and lowers the
//  collision probability. Collisions between BSSs are a necessary
//  condition to see the improvements brought by spatial reuse, and
//  thus increasing the amount of generated traffic by setting the
//  interval argument to a lower value is necessary to see the
//  benefits of spatial reuse in this scenario. This can, for
//  instance, be accomplished by setting --interval=0.0001.
*/
 
#include "ns3/abort.h"
#include "ns3/ap-wifi-mac.h"
#include "ns3/application-container.h"
#include "ns3/command-line.h"
#include "ns3/config.h"
#include "ns3/double.h"
#include "ns3/he-configuration.h"
#include "ns3/mobility-helper.h"
#include "ns3/multi-model-spectrum-channel.h"
#include "ns3/packet-socket-client.h"
#include "ns3/packet-socket-helper.h"
#include "ns3/packet-socket-server.h"
#include "ns3/spectrum-wifi-helper.h"
#include "ns3/ssid.h"
#include "ns3/string.h"
#include "ns3/wifi-net-device.h"

// Added for Acsii trace - Modified, not used - failed to work
// #include "ns3/trace-helper.h"

// Added for Flow monitor - Modified, not used - failed to work
/* #include "ns3/flow-monitor.h"
#include "ns3/flow-monitor-helper.h"
*/

// Added for Netanim - Modified, not used
// #include "ns3/netanim-module.h"
 
using namespace ns3;
 
std::vector<uint32_t> bytesReceived(4);
 
uint32_t
ContextToNodeId(std::string context)
{
    std::string sub = context.substr(10);
    uint32_t pos = sub.find("/Device");
    return std::stoi(sub.substr(0, pos));
}
 
void
SocketRx(std::string context, Ptr<const Packet> p, const Address& addr)
{
    uint32_t nodeId = ContextToNodeId(context);
    bytesReceived[nodeId] += p->GetSize();
}
 
int
main(int argc, char* argv[])
{
    // The parameters of the simulation that can be changed
    double duration = 10.0;      // seconds

    double d1 = 10.00;          // meters - Modified code - Distance between AP1, AP2
    double d2 = -10.00;         // meters - Modified code - Distance between AP3, AP1
    //double d6 = 10.00;          // meters - Modified code, BSS 4 setup that fails to work
    //double d7 = -15.00;         // meters - Modified code, BSS 4 setup that fails to work
    //double d8 = 15.00;        // meters - Modified code, BSS 4 setup that fails to work

    double x1 = 0.00;           // meters - Modified code - X axis - Distance between STA 1, AP1
    double x2 = 10.00;          // meters - Modified code - X axis - Distance between STA 2, AP2
    double x3 = 0.00;           // meters - Modified code - X axis - Distance between STA 3, AP3

    double y1 = 5.00;           // meters - Modified code - Distance between STA 1, AP1
    double y2 = 5.00;           // meters - Modified code - Distance between STA 2, AP2
    double y3 = -15.00;         // meters - Modified code - Distance between STA 3, AP3

    double powSta1 = 10.0;       // dBm
    double powSta2 = 10.0;       // dBm
    double powSta3 = 10.0;       // dBm Modified code
    //double powSta4 = 10.0;       // dBm Modified code, BSS 4 setup that fails to work

    double powAp1 = 21.0;        // dBm
    double powAp2 = 21.0;        // dBm
    double powAp3 = 21.0;        // dBm Modified code
    //double powAp4 = 21.0;        // dBm Modified code, BSS 4 setup that fails to work

    double ccaEdTrSta1 = -62;    // dBm
    double ccaEdTrSta2 = -62;    // dBm
    double ccaEdTrSta3 = -62;    // dBm Modified code
    //double ccaEdTrSta4 = -62;    // dBm Modified code, BSS 4 setup that fails to work

    double ccaEdTrAp1 = -62;     // dBm
    double ccaEdTrAp2 = -62;     // dBm
    double ccaEdTrAp3 = -62;     // dBm Modified code
    //double ccaEdTrAp4 = -62;     // dBm Modified code, BSS 4 setup that fails to work

    double minimumRssi = -82;    // dBm
    int channelBandwidth = 40;   // MHz
    uint32_t payloadSize = 1500; // bytes
    uint32_t mcs = 0;            // MCS value
    double interval = 0.001;     // seconds
    bool enableObssPd = true;   // Toggle sim BSS colouring on/off
    double obssPdThreshold = -72.0; // dBm
 
    // Terminal command line options to change parameters of simulation
    CommandLine cmd(__FILE__);
    cmd.AddValue("duration", "Duration of simulation (s)", duration);
    cmd.AddValue("interval", "Inter packet interval (s)", interval);
    cmd.AddValue("enableObssPd", "Enable/disable OBSS_PD", enableObssPd);
    cmd.AddValue("d1", "Distance between AP1 and AP2 (m)", d1); // Modified code
    cmd.AddValue("d2", "Distance between AP1 and AP3 (m)", d2); // Modified code
    cmd.AddValue("y1", "Y axis distance between STA1 and AP1 (m)", y1); // Modified code
    cmd.AddValue("y2", "Y axis distance between STA2 and AP2 (m)", y2); // Modified code
    cmd.AddValue("y3", "Y axis distance between STA3 and AP3 (m)", y3); // Modified code
    cmd.AddValue("x1", "X axis distance between STA1 and AP1 (m)", x1); // Modified code
    cmd.AddValue("x2", "X axis distance between STA2 and AP2 (m)", x2); // Modified code
    cmd.AddValue("x3", "X axis distance between STA3 and AP3 (m)", x3); // Modified code
    // Distancec for AP 4 and STA 4 - Modified code, BBS 4 failed to work with script
    /* 
    cmd.AddValue("d6", "Distance between AP3 and AP4 (m)", d6); // Modified code
    cmd.AddValue("d7", "Distance between AP4 and AP2 (m)", d7); // Modified code
    cmd.AddValue("d8", "Distance between STA4 and AP4 (m)", d8); // Modified code
    */

    cmd.AddValue("powSta1", "Power of STA1 (dBm)", powSta1);
    cmd.AddValue("powSta2", "Power of STA2 (dBm)", powSta2);
    cmd.AddValue("powSta3", "Power of STA3 (dBm)", powSta3); // Modified code
    //cmd.AddValue("powSta3", "Power of STA3 (dBm)", powSta4); // Modified code, BBS 4 failed to work with script

    cmd.AddValue("powAp1", "Power of AP1 (dBm)", powAp1);
    cmd.AddValue("powAp2", "Power of AP2 (dBm)", powAp2);
    cmd.AddValue("powAp3", "Power of AP3 (dBm)", powAp3); // Modified code
    //cmd.AddValue("powAp2", "Power of AP4 (dBm)", powAp4); // Modified code, BBS 4 failed to work with script

    cmd.AddValue("ccaEdTrSta1", "CCA-ED Threshold of STA1 (dBm)", ccaEdTrSta1);
    cmd.AddValue("ccaEdTrSta2", "CCA-ED Threshold of STA2 (dBm)", ccaEdTrSta2);
    cmd.AddValue("ccaEdTrSta3", "CCA-ED Threshold of STA3 (dBm)", ccaEdTrSta3); // Modified code
    //cmd.AddValue("ccaEdTrSta2", "CCA-ED Threshold of STA4 (dBm)", ccaEdTrSta4); // Modified code, BBS 4 failed to work with script

    cmd.AddValue("ccaEdTrAp1", "CCA-ED Threshold of AP1 (dBm)", ccaEdTrAp1);
    cmd.AddValue("ccaEdTrAp2", "CCA-ED Threshold of AP2 (dBm)", ccaEdTrAp2);
    cmd.AddValue("ccaEdTrAp3", "CCA-ED Threshold of AP3 (dBm)", ccaEdTrAp3); // Modified code
    //cmd.AddValue("ccaEdTrAp2", "CCA-ED Threshold of AP3 (dBm)", ccaEdTrAp4); // Modified code, BBS 4 failed to work with script
    cmd.AddValue("minimumRssi",
                 "Minimum RSSI for the ThresholdPreambleDetectionModel",
                 minimumRssi);
    cmd.AddValue("channelBandwidth",
                 "Bandwidth of the channel in MHz [20, 40, or 80]",
                 channelBandwidth);
    cmd.AddValue("obssPdThreshold", "Threshold for the OBSS PD Algorithm", obssPdThreshold);
    cmd.AddValue("mcs", "The constant MCS value to transmit HE PPDUs", mcs);
    cmd.Parse(argc, argv);
    
    // Create STA and AP nodes
    NodeContainer wifiStaNodes;
    wifiStaNodes.Create(3);
 
    NodeContainer wifiApNodes;
    wifiApNodes.Create(3);
    
    // 5Ghz band and channel spectrum setup
    SpectrumWifiPhyHelper spectrumPhy;
    Ptr<MultiModelSpectrumChannel> spectrumChannel = CreateObject<MultiModelSpectrumChannel>();
    Ptr<FriisPropagationLossModel> lossModel = CreateObject<FriisPropagationLossModel>();
    spectrumChannel->AddPropagationLossModel(lossModel);
    Ptr<ConstantSpeedPropagationDelayModel> delayModel =
        CreateObject<ConstantSpeedPropagationDelayModel>();
    spectrumChannel->SetPropagationDelayModel(delayModel);
 
    spectrumPhy.SetChannel(spectrumChannel);
    spectrumPhy.SetErrorRateModel("ns3::YansErrorRateModel");
    switch (channelBandwidth)
    {
    case 20:
        spectrumPhy.Set("ChannelSettings", StringValue("{36, 20, BAND_5GHZ, 0}"));
        break;
    case 40:
        spectrumPhy.Set("ChannelSettings", StringValue("{62, 40, BAND_5GHZ, 0}"));
        break;
    case 80:
        spectrumPhy.Set("ChannelSettings", StringValue("{171, 80, BAND_5GHZ, 0}"));
        break;
    default:
        NS_ABORT_MSG("Unrecognized channel bandwidth: " << channelBandwidth);
        break;
    }
    spectrumPhy.SetPreambleDetectionModel("ns3::ThresholdPreambleDetectionModel",
                                          "MinimumRssi",
                                          DoubleValue(minimumRssi));
    
    // Set Wi-Fi 6 standard and include BSS colouring if enabled
    WifiHelper wifi;
    wifi.SetStandard(WIFI_STANDARD_80211ax);
    if (enableObssPd)
    {
        wifi.SetObssPdAlgorithm("ns3::ConstantObssPdAlgorithm",
                                "ObssPdLevel",
                                DoubleValue(obssPdThreshold));

    }

 
    WifiMacHelper mac;
    std::ostringstream oss;
    oss << "HeMcs" << mcs;
    wifi.SetRemoteStationManager("ns3::ConstantRateWifiManager",
                                 "DataMode",
                                 StringValue(oss.str()),
                                 "ControlMode",
                                 StringValue(oss.str()));

    // BSS 1 properties and colouring setup
    spectrumPhy.Set("TxPowerStart", DoubleValue(powSta1));
    spectrumPhy.Set("TxPowerEnd", DoubleValue(powSta1));
    spectrumPhy.Set("CcaEdThreshold", DoubleValue(ccaEdTrSta1));
    spectrumPhy.Set("RxSensitivity", DoubleValue(-92.0));

    Ssid ssidA = Ssid("A");
    mac.SetType("ns3::StaWifiMac", "Ssid", SsidValue(ssidA));
    NetDeviceContainer staDeviceA = wifi.Install(spectrumPhy, mac, wifiStaNodes.Get(0));
 
    spectrumPhy.Set("TxPowerStart", DoubleValue(powAp1));
    spectrumPhy.Set("TxPowerEnd", DoubleValue(powAp1));
    spectrumPhy.Set("CcaEdThreshold", DoubleValue(ccaEdTrAp1));
    spectrumPhy.Set("RxSensitivity", DoubleValue(-92.0));
 
    mac.SetType("ns3::ApWifiMac", "Ssid", SsidValue(ssidA));
    NetDeviceContainer apDeviceA = wifi.Install(spectrumPhy, mac, wifiApNodes.Get(0));
 
    Ptr<WifiNetDevice> apDevice = apDeviceA.Get(0)->GetObject<WifiNetDevice>();
    Ptr<ApWifiMac> apWifiMac = apDevice->GetMac()->GetObject<ApWifiMac>();
    if (enableObssPd)
    {
        apDevice->GetHeConfiguration()->SetAttribute("BssColor", UintegerValue(1));
    }
 
//BSS 2 properties and colouring setup
    spectrumPhy.Set("TxPowerStart", DoubleValue(powSta2));
    spectrumPhy.Set("TxPowerEnd", DoubleValue(powSta2));
    spectrumPhy.Set("CcaEdThreshold", DoubleValue(ccaEdTrSta2));
    spectrumPhy.Set("RxSensitivity", DoubleValue(-92.0));
 
    Ssid ssidB = Ssid("B");
    mac.SetType("ns3::StaWifiMac", "Ssid", SsidValue(ssidB));
    NetDeviceContainer staDeviceB = wifi.Install(spectrumPhy, mac, wifiStaNodes.Get(1));
 
    spectrumPhy.Set("TxPowerStart", DoubleValue(powAp2));
    spectrumPhy.Set("TxPowerEnd", DoubleValue(powAp2));
    spectrumPhy.Set("CcaEdThreshold", DoubleValue(ccaEdTrAp2));
    spectrumPhy.Set("RxSensitivity", DoubleValue(-92.0));
 
    mac.SetType("ns3::ApWifiMac", "Ssid", SsidValue(ssidB));
    NetDeviceContainer apDeviceB = wifi.Install(spectrumPhy, mac, wifiApNodes.Get(1));
 
    Ptr<WifiNetDevice> ap2Device = apDeviceB.Get(0)->GetObject<WifiNetDevice>();
    apWifiMac = ap2Device->GetMac()->GetObject<ApWifiMac>();
    if (enableObssPd)
    {
        ap2Device->GetHeConfiguration()->SetAttribute("BssColor", UintegerValue(2));
    }
 
// BSS 3 properties and colouring setup - Modified code, added to original script
    spectrumPhy.Set("TxPowerStart", DoubleValue(powSta3));
    spectrumPhy.Set("TxPowerEnd", DoubleValue(powSta3));
    spectrumPhy.Set("CcaEdThreshold", DoubleValue(ccaEdTrSta3));
    spectrumPhy.Set("RxSensitivity", DoubleValue(-92.0));

    Ssid ssidC = Ssid("C");
    mac.SetType("ns3::StaWifiMac", "Ssid", SsidValue(ssidC));
    NetDeviceContainer staDeviceC = wifi.Install(spectrumPhy, mac, wifiStaNodes.Get(2));
 
    spectrumPhy.Set("TxPowerStart", DoubleValue(powAp3));
    spectrumPhy.Set("TxPowerEnd", DoubleValue(powAp3));
    spectrumPhy.Set("CcaEdThreshold", DoubleValue(ccaEdTrAp3));
    spectrumPhy.Set("RxSensitivity", DoubleValue(-92.0));
 
    mac.SetType("ns3::ApWifiMac", "Ssid", SsidValue(ssidC));
    NetDeviceContainer apDeviceC = wifi.Install(spectrumPhy, mac, wifiApNodes.Get(2));
 
    Ptr<WifiNetDevice> ap3Device = apDeviceC.Get(0)->GetObject<WifiNetDevice>();
    apWifiMac = ap3Device->GetMac()->GetObject<ApWifiMac>();
    if (enableObssPd)
    {
        ap3Device->GetHeConfiguration()->SetAttribute("BssColor", UintegerValue(3));
    }
 
 // BSS 4 properties and colouring setup - Modified code, failed to work, breaks script
/*
    spectrumPhy.Set("TxPowerStart", DoubleValue(powSta4));
    spectrumPhy.Set("TxPowerEnd", DoubleValue(powSta4));
    spectrumPhy.Set("CcaEdThreshold", DoubleValue(ccaEdTrSta4));
    spectrumPhy.Set("RxSensitivity", DoubleValue(-92.0));

    Ssid ssidD = Ssid("D");
    mac.SetType("ns3::StaWifiMac", "Ssid", SsidValue(ssidD));
    NetDeviceContainer staDeviceD = wifi.Install(spectrumPhy, mac, wifiStaNodes.Get(3));
 
    spectrumPhy.Set("TxPowerStart", DoubleValue(powAp4));
    spectrumPhy.Set("TxPowerEnd", DoubleValue(powAp4));
    spectrumPhy.Set("CcaEdThreshold", DoubleValue(ccaEdTrAp4));
    spectrumPhy.Set("RxSensitivity", DoubleValue(-92.0));
 
    mac.SetType("ns3::ApWifiMac", "Ssid", SsidValue(ssidD));
    NetDeviceContainer apDeviceD = wifi.Install(spectrumPhy, mac, wifiApNodes.Get(3));
 
    Ptr<WifiNetDevice> ap4Device = apDeviceD.Get(0)->GetObject<WifiNetDevice>();
    apWifiMac = ap4Device->GetMac()->GetObject<ApWifiMac>();
    if (enableObssPd)
    {
        ap3Device->GetHeConfiguration()->SetAttribute("BssColor", UintegerValue(4));
    }
    */

    // Mobility setup, grid positions of APs and STAs - PositionAlloc grid description (X axis, Y axis, Z axis )
    MobilityHelper mobility;
    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();
    positionAlloc->Add(Vector(0.0, 0.0, 0.0)); // AP1
    positionAlloc->Add(Vector(d1, 0.0, 0.0));  // AP2
    positionAlloc->Add(Vector(0.0, d2, 0.0));  // AP3 - Modified code, added to orginal script
    //positionAlloc->Add(Vector(d6, d5, 0.0));  // AP4 - Modified code, failed to work

    positionAlloc->Add(Vector(x1, y1, 0.0));  // STA1 - Modified code, added X&Y axis parameter
    positionAlloc->Add(Vector(x2, y2, 0.0));   // STA2 - Modified code, added X&Y axis parameter
    positionAlloc->Add(Vector(x3, y3, 0.0));  // STA3 - Modified code, added X&Y axis parameter
   // positionAlloc->Add(Vector(d6, d8, 0.0));  // STA4 - Modified code, failed to work
    mobility.SetMobilityModel("ns3::ConstantPositionMobilityModel");
    mobility.SetPositionAllocator(positionAlloc);
    mobility.Install(wifiApNodes); // Order of positions above will apply to AP nodes then STA nodes
    mobility.Install(wifiStaNodes);
    
    // Network Traffic setup
    PacketSocketHelper packetSocket;
    packetSocket.Install(wifiApNodes);
    packetSocket.Install(wifiStaNodes);
    ApplicationContainer apps;
 
    // BSS 1 run setup
    {
        PacketSocketAddress socketAddr;
        socketAddr.SetSingleDevice(staDeviceA.Get(0)->GetIfIndex());
        socketAddr.SetPhysicalAddress(apDeviceA.Get(0)->GetAddress());
        socketAddr.SetProtocol(1);
        Ptr<PacketSocketClient> client = CreateObject<PacketSocketClient>();
        client->SetRemote(socketAddr);
        wifiStaNodes.Get(0)->AddApplication(client);
        client->SetAttribute("PacketSize", UintegerValue(payloadSize));
        client->SetAttribute("MaxPackets", UintegerValue(0));
        client->SetAttribute("Interval", TimeValue(Seconds(interval)));
        Ptr<PacketSocketServer> server = CreateObject<PacketSocketServer>();
        server->SetLocal(socketAddr);
        wifiApNodes.Get(0)->AddApplication(server);
    }
 
    // BSS 2 run setup
    {
        PacketSocketAddress socketAddr;
        socketAddr.SetSingleDevice(staDeviceB.Get(0)->GetIfIndex());
        socketAddr.SetPhysicalAddress(apDeviceB.Get(0)->GetAddress());
        socketAddr.SetProtocol(1);
        Ptr<PacketSocketClient> client = CreateObject<PacketSocketClient>();
        client->SetRemote(socketAddr);
        wifiStaNodes.Get(1)->AddApplication(client);
        client->SetAttribute("PacketSize", UintegerValue(payloadSize));
        client->SetAttribute("MaxPackets", UintegerValue(0));
        client->SetAttribute("Interval", TimeValue(Seconds(interval)));
        Ptr<PacketSocketServer> server = CreateObject<PacketSocketServer>();
        server->SetLocal(socketAddr);
        wifiApNodes.Get(1)->AddApplication(server);
    }

    // BSS 3 run setup - Modified code, added to original script
    {
        PacketSocketAddress socketAddr;
        socketAddr.SetSingleDevice(staDeviceC.Get(0)->GetIfIndex());
        socketAddr.SetPhysicalAddress(apDeviceC.Get(0)->GetAddress());
        socketAddr.SetProtocol(1);
        Ptr<PacketSocketClient> client = CreateObject<PacketSocketClient>();
        client->SetRemote(socketAddr);
        wifiStaNodes.Get(2)->AddApplication(client);
        client->SetAttribute("PacketSize", UintegerValue(payloadSize));
        client->SetAttribute("MaxPackets", UintegerValue(0));
        client->SetAttribute("Interval", TimeValue(Seconds(interval)));
        Ptr<PacketSocketServer> server = CreateObject<PacketSocketServer>();
        server->SetLocal(socketAddr);
        wifiApNodes.Get(2)->AddApplication(server);
    }

    // BSS 4 run setup - Modified code, failed to work and breaks script
    /*
    {
        PacketSocketAddress socketAddr;
        socketAddr.SetSingleDevice(staDeviceD.Get(0)->GetIfIndex());
        socketAddr.SetPhysicalAddress(apDeviceD.Get(0)->GetAddress());
        socketAddr.SetProtocol(1);
        Ptr<PacketSocketClient> client = CreateObject<PacketSocketClient>();
        client->SetRemote(socketAddr);
        wifiStaNodes.Get(2)->AddApplication(client);
        client->SetAttribute("PacketSize", UintegerValue(payloadSize));
        client->SetAttribute("MaxPackets", UintegerValue(0));
        client->SetAttribute("Interval", TimeValue(Seconds(interval)));
        Ptr<PacketSocketServer> server = CreateObject<PacketSocketServer>();
        server->SetLocal(socketAddr);
        wifiApNodes.Get(3)->AddApplication(server);
    }
    */

    Config::Connect("/NodeList/*/ApplicationList/*/$ns3::PacketSocketServer/Rx",
                    MakeCallback(&SocketRx));
 
    


    // Flow monitor initialise code - Modified code - Works but output file code failed
    /*Ptr<FlowMonitor> flowMonitor;
    FlowMonitorHelper flowHelper;
    flowMonitor = flowHelper.InstallAll();
    */



    Simulator::Stop(Seconds(duration));

// Netanim run - Modified code - used initailly to visualise positions of nodes, no longer used in code
    /*
    AnimationInterface anim("anim-spatical-reuse.xml");
    anim.SetMaxPktsPerTraceFile(50000);
    anim.SetConstantPosition(wifiApNodes.Get(0), 0.0, 0.0, 0.0); // AP 1
    anim.SetConstantPosition(wifiApNodes.Get(1), d1, 0.0, 0.0);  // AP 2
    anim.SetConstantPosition(wifiApNodes.Get(2), 0.0, d2, 0.0);  // AP 3
    anim.SetConstantPosition(wifiApNodes.Get(2), d6, d7, 0.0);   // AP 4

    anim.SetConstantPosition(wifiStaNodes.Get(0), x1, y1, 0.0);  // STA 1
    anim.SetConstantPosition(wifiStaNodes.Get(1), x2, y2, 0.0);  // STA 2
    anim.SetConstantPosition(wifiStaNodes.Get(2), x3, y3, 0.0);  // STA 3
    anim.SetConstantPosition(wifiStaNodes.Get(2), d6, d8, 0.0);  // STA 4
    */

// Ascii trace file output code - Modified code, failed to work and breaks script
    /*AsciiTraceHelper ascii;
    wifiStaNodes.EnableAsciiAll(ascii.CreateFileStream ("ascii-trace-spatial-reuse.tr"));
    */


    Simulator::Run();

// Flow monitor output XML file line - modified code, failed to work and breaks script
    //flowMonitor->SerializeToXmlFile("flowmonitor-wifi-spatial-reuse.xml", true, true);

    Simulator::Destroy();

    
    for (uint32_t i = 0; i < 3; i++) // Modified code - updated to output 3 sets of results generated for 3 BSSs in CLI
    {
        double throughput = static_cast<double>(bytesReceived[2 + i]) * 8 / 1000 / 1000 / duration;
        std::cout << "Throughput for BSS " << i + 1 << ": " << throughput << " Mbit/s" << std::endl;
    }


    return 0;

}
